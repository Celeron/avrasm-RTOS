;=== BEGIN "data.inc" ======================================================


;***************************************************************************
;*
;*  Глобальные константы и Псевдонимы регистров
;*
;***************************************************************************
;
; Тут определяются Кастомные пользовательские: 
; 	глобальные константы (через .equ)
; 	псевдонимы регистров (через .def)
;
;
; КРАТКАЯ СПРАВКА:
;
; Q: Чем отличаются директивы .def и .equ ?
; A: .equ означает что «Теперь вот это слово равно/эквивалентно этому числу и вместо числа может быть слово»
;    .def означает что «Теперь этот регистр можно обозвать еще и таким словом»
;
;    Регистру мы можем присвоить кучу разных имен и это не будет ошибкой (варнинг будет, но на него можно забить).
;    А вот заэквивалентить одному слову несколько чисел уже нельзя (наоборот, разным словам одно число — запросто, без проблем).
;
;
; Q: Возможно ли присвоить имя не регистру, а скажем порту в/в, или даже лучше конкретному пину порта!? 
;    Возможно, ли определенным ИМЕНАМ присвоить значение?!
; 
; A: Можно, но DEF - работает ТОЛЬКО С РЕГИСТРАМИ (определяет им псевдонимы)!
;    А вот имена портов - это не более чем: EQU номера порта в имя порта (именно они прописаны в hal.inc файлах, для соответствующих мк).
; 
;    Пример:
; 	.def COK = R26
; 	.def SEDOK = R27
; 	.def Catch = R28
; 	.def Armed = R29
; 
; 	.equ R_ON = 6
; 	.equ R_ON_P = PORTB
; 	.equ R_ON_D = DDRB
; 
; 	.equ R_EN = 7
; 	.equ R_EN_P = PORTB
; 	.equ R_EN_D = DDRB
;
;---------------------------------------------------------------------------



; Временные регистры, используемые в основном прикладном коде:
;.def	temp	= R16	; (определено в macrobaselib.inc)
;.def	temp1	= R16	; (определено в macrobaselib.inc)
;.def	temp2	= R17	; (определено в macrobaselib.inc)
;.def	temp3	= R18	; (определено в macrobaselib.inc)
;.def	temp4	= R19	; (определено в macrobaselib.inc)




;***************************************************************************
;*
;*  Энергонезависимая память EEPROM (сегмент ППЗУ)
;*
;***************************************************************************
			.ESEG

		; Fi5t предупреждает, в комментарии к http://easyelectronics.ru/avr-uchebnyj-kurs-ispolzovanie-eeprom.html
		;	"У атмеловских контроллеров есть так называемая «мертвая зона» EEPROM-a. У 64й атмеги, например, это все адреса от 0?00 — 0?100. Так же была замечена тенденция (по крайней мере на атмегах), чем круче модель (ATMeag32->64->128), тем больше у нее мертвая зона EEPROM. Причем в документации, про нее нифига не написано и подбирать придется в ручную. 
		; 	Ах да, чем же она такая мертвая эта зона. А тем, что запись и чтение в ней происходят через раз, а то и не происходят вообще. Дрочится конечно можно, но лучше оставить эти 100 адресов на советси разработчиков и работать со стабильным ПЗУ."
		; TODO: Протестировать стабильность работы готового устройства! 
		;	Экспериментально определить наличие и размер "мёртвой зоны EEPROM". 
		; 	При необходимости, сместить диапазон используемой памяти на несколько байтов вперёд, за пределы "мёртвой зоны":
		;.ORG	<адрес за пределами "мёртвой зоны EEPROM">	; Note: Byte address




;***************************************************************************
;*
;*  Константные массивы в памяти FLASH (сегмент кода)
;*
;***************************************************************************
			.CSEG

		; Важно! Блок-врезка с константными данными должен располагаться в памяти: 
		; после основного кода, и не пересекаться ни с Boot-блоком, ни с другими врезками!
		; Подберите смещение соответственно:
		;.ORG	(FLASHEND - <количество требуемой под блок констант памяти, в словах по 2байта>)	; Note: Word address
		.ORG	(FLASHEND-50)	; определяем карман из 100байт, в самом конце flash-памяти.


; Зачем это?
; Поскольку в Микроконтроллере зашито больше всего объёма памяти типа Flash, используемой обычно для программного кода, то зачастую, часть из этого пространства остатся незанятой.
; Неиспользуемый остаток может быть использован для хранения массивов неизменных данных: таблица значений функции, псевдокод программных автоматов, таблицы (пере)кодировок, и т.п.


; Пример распределения памяти:
;
; MyConstArray: .db 13, 69, 66, 39, 75, 31
; 		.db 35, 18, 87, 21, 32, 46
; 		.db 123,38, 86, 89, 93, 75
; 		.db 54, 47, 59, 98, 76, 6
; 		.db 147,59, 239,244,170,66
; 		.db 92, 162,1,  7,  28, 89
; 		.db 78, 5,  15, 154,38, 19
; 		.db 84, 7,  33, 8,  77, 94
; 		.db 93, 56, 5,  99, 89, 54
; 		.db 3,  54, 63, 6,  65, 84
; 		.db 213,90, 83, 111,159,8	
;
; Внимание: здесь, в каждой директиве .DB следует, по возможности, расмещать ПАРНОЕ КОЛИЧЕСТВО чисел - поскольку пары байт упаковываются в пакеты-слова:
; If the DB directive is given in a Code Segment and the expressionlist contains more than one expression, the expressions are packed so that two bytes are placed in each program memory word. 
; If the expressionlist contains an odd number of expressions, the last expression will be placed in a program memory word of its own, even if the next line in the assemby code contains a DB directive. 
; The unused half of the program word is set to zero. A warning is given, in order to notify the user that an extra zero byte is added to the .DB statement.


; Памятка: как обращаться к этой памяти, подгружать из неё данные (инструкцией LPM) - 
; см. статью DI HALT "AVR. Учебный Курс. Работа с памятью" / подраздел "Флеш память" 
; http://easyelectronics.ru/avr-uchebnyj-kurs-ispolzovanie-flash-rom.html

;---------------------------------------------------------------------------




;***************************************************************************
;*
;*  Оперативная память SRAM (сегмент ОЗУ)
;*
;***************************************************************************
			.DSEG


;DCnt:	.byte	1	; Некоторые переменные в памяти (для решения прикладной задачи)



;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в конце сегмента данных!)
;===========================================================================
	.include "RTOS_data.inc"	; Подключаем Настройки, Данные и Определения, для работы ядра RTOS
;===========================================================================



;=== END "data.inc" ========================================================
; coded by (c) Celeron, 2014  http://inventproject.info/
