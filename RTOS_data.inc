;=== BEGIN "RTOS-data.inc" =================================================


;***************************************************************************
;*
;*  Оперативная память SRAM (сегмент ОЗУ), для RTOS
;*
;***************************************************************************


	.ifdef	RTOS_FEATURE_PLANTASKTIMED
			.equ 	RTOS_TimersPoolSize 	= 5	; Длина пула Таймеров [1..255] (максимально возможное число одновременно существующих "отложенных задач" в системе)
RTOS_TimersPool:	.byte	RTOS_TimersPoolSize*3		; Адрес пула Таймеров
	.endif



	.ifdef	RTOS_FEATURE_PLANTASKWAITER
			.equ 	RTOS_WaitersPoolSize 	= 5	; Длина пула Выжидающих [1..255] (максимально возможное число одновременно существующих "отложенных задач" в системе)
RTOS_WaitersPool:	.byte	RTOS_WaitersPoolSize*3		; Адрес пула Выжидающих

; Формат 3-го байта элемента пула Выжидающих:
.equ	WAITER_BIT_STATE	= 7	; Ожидаемое состояние бита, которое должено быть в тестируемой [байтовой] ячейке памяти, для запуска Задачи на выполнение.
.equ	WAITER_BIT_POSITION	= 4	; Следующие три бита кодируют номер позиции [0..7] тестируемого бита (в байтовой ячейке).
.equ	WAITER_ADDRESS_HIGH	= 0	; Следующие четыре бита кодируют ст.байт адреса ячейки.
	.endif



	.ifdef	RTOS_FEATURE_PLANTASK
			.equ 	RTOS_TaskQueueSize 	= 11	; Длина очереди Задач [1..255] (задается с запасом, чтобы не произошло ее переполнения)
RTOS_TaskQueue:		.byte	RTOS_TaskQueueSize 		; Адрес очереди Задач (примечание: располагать ее лучше после остальных данных, чтобы она тянулась навстречу стеку)
	.endif



;---------------------------------------------------------------------------

; КРАТКАЯ СПРАВКА:



; Формат элемента пула программных Таймеров (RTOS_TimersPool):
; Время разбивается на интервалы, скажем, по 1мс. Такой выдержки хватает для большинства задач. 
; Также у нас должна быть очередь программных таймеров, размещенных в ОЗУ. На каждый таймер отводится три байта:
; 
; 	1 байт		2 байт		3 байт
; 	76543210	76543210	76543210
; 	nnnnnnnn	tttttttt	TTTTTTTT
; 
; где:
; 	nnnnnnnn	- Идентификатор Задачи	(где задача==0 означает "нет Таймера")
; 	tttttttt	— выдержка в миллисекундах (мл.байл) /little-endian/
; 	TTTTTTTT	— выдержка в миллисекундах (ст.байл)
; 
; Два байта позволяют организовать выдержку в 65,5 секунд.
; Один из свободных аппаратных таймеров программируем на то, чтобы он генерировал прерывание каждые 0.001с 
; По прерыванию аппаратного таймера - запускается обработчик RTOS_TIMER_SERVICE...




; Формат элемента пула Выжидающих (RTOS_WaitersPool):
; 
; 	1 байт		2 байт		3 байт
; 	76543210	76543210	76543210
; 	nnnnnnnn	aaaaaaaa	BpppAAAA
; 
; где:
; 	nnnnnnnn	- Идентификатор Задачи	(где задача==0 означает "нет Выжидающего")
; 	B		- Ожидаемое состояние бита, которое должено быть в тестируемой байтовой ячейке, для запуска Задачи на выполнение.
; 	ppp		- три бита кодируют номер позиции [0..7] тестируемого бита B в байтовой ячейке.
; 	AAAAaaaaaaaa	- 12-битный адрес [0x00..0x0FFF] тестируемой байтовой ячейки ОЗУ (регистра/порта/SRAM), даёт 4Kb диапазон адресации. Где "aaaaaaaa" - мл.байт, "AAAA" - ст.байт адреса.
; 
; Память вычитывается инструкцией "LD" (что даёт сквозную адресацию памяти).
; Итак, доступно к адресации 4Kb памяти (4096 байт): в т.ч. РОН, регистры ввода/вывода, SRAM.
; Из них, охватываемый диапазон SRAM = 0x1000 - SRAM_START. Что возможно будет меньше, чем вся доступная память SRAM_SIZE? 
; 	Этого вполне достаточно для подавляющего большинства используемых МК: младших моделей (с 2Kb и менее SRAM).
; 	Адресации не хватит только для самых мощных МК (с 4Кб и более SRAM), для которых уже не рассчитана сама ассемблерная RTOS - слишком много памяти, нужно программировать на Си...
; 	Например, для ATmega64 и ATmega128 - покрывается только 93% из  4Кб SRAM. (ещё можно как-то использовать, учитывая, что в конце памяти - только Стек, нет статических данных)
; 	          для ATmega640            - покрывается только 43% из  8Кб SRAM.
; 	          для ATmega1284           - покрывается только 23% из 16Кб SRAM.




; Формат элемента очереди Задач (RTOS_TaskQueue):
; 	просто вектор из байтов, Номеров-индексов Задач...




;=== END "RTOS-data.inc" ===================================================
; coded by (c) Celeron, 2014 @ http://we.easyelectronics.ru/my/Celeron/
