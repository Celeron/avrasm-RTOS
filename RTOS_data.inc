;=== BEGIN "RTOS-data.inc" =================================================


;***************************************************************************
;*
;*  Оперативная память SRAM (сегмент ОЗУ), для RTOS
;*
;***************************************************************************
.ifdef	RTOS_FEATURE_PLANTASK



	.if defined(RTOS_FEATURE_PLANTIMER) || defined(RTOS_FEATURE_PLANWAITER)	; (служба таймеров используется только в этих режимах)
RTOS_TimerServiceCounter:	.byte	1			; Вспомогательный Счётчик для "Службы таймеров RTOS" = [0..255]:
								; Хранит количество прерываний аппаратного таймера (RTOS_TIMER_SERVICE), прошедшее с момента последней отработки системного метода (RTOS_METHOD_TimerService).
								; Данный счётчик наращивается в обработчике прерывания аппаратного таймера (RTOS_TIMER_SERVICE) и сигнализирует системному методу (RTOS_METHOD_TimerService), что с момента его прошлой отработки, уже прошла 1мс или более (конкретное число тиков с тех пор - хранит Счётчик), и надо обработать все Пулы...
	.endif




	.ifdef	RTOS_FEATURE_PLANTIMER
			.equ 	RTOS_TimersPoolSize 	= 5	; Длина пула Таймеров    [1..85] (максимально возможное число одновременно существующих "отложенных задач" в системе)
RTOS_TimersPool:	.byte	RTOS_TimersPoolSize*3		; Адрес пула Таймеров

	.if RTOS_TimersPoolSize<1 || RTOS_TimersPoolSize>85
	.ERROR "RTOS_TimersPoolSize must be in [1..85]!"
	.endif
	.endif




	.ifdef	RTOS_FEATURE_PLANWAITER
			.equ 	RTOS_WaitersPoolSize 	= 5	; Длина пула Выжидателей [1..85] (максимально возможное число одновременно существующих "отложенных задач" в системе)
RTOS_WaitersPool:	.byte	RTOS_WaitersPoolSize*3		; Адрес пула Выжидателей

; Формат 3-го байта элемента пула Выжидателей:
.equ	WAITER_BIT_STATE	= 7	; Ожидаемое состояние бита, которое должено быть в тестируемой [байтовой] ячейке памяти, для запуска Задачи на выполнение.
.equ	WAITER_BIT_POSITION	= 4	; Следующие три бита кодируют номер позиции [0..7] тестируемого бита (в байтовой ячейке).
.equ	WAITER_ADDRESS_HIGH	= 0	; Следующие четыре бита кодируют ст.байт адреса ячейки.

	.if RTOS_WaitersPoolSize<1 || RTOS_WaitersPoolSize>85
	.ERROR "RTOS_WaitersPoolSize must be in [1..85]!"
	.endif
	.endif




			.equ 	RTOS_TaskQueueSize 	= 11	; Длина очереди Задач [1..255] (задается с запасом, чтобы не произошло ее переполнения)
RTOS_TaskQueue:		.byte	RTOS_TaskQueueSize 		; Адрес очереди Задач (примечание: располагать ее лучше после остальных данных, чтобы она тянулась навстречу стеку)

	.if RTOS_TaskQueueSize<1 || RTOS_TaskQueueSize>255
	.ERROR "RTOS_TaskQueueSize must be in [1..255]!"
	.endif



.endif	//RTOS_FEATURE_PLANTASK	(Базовая диспетчеризация задач, строго необходима для работы всех функций RTOS)
;---------------------------------------------------------------------------

; КРАТКАЯ СПРАВКА:



; Формат элемента пула программных Таймеров (RTOS_TimersPool):
; Время разбивается на интервалы, скажем, по 1мс. Такой выдержки хватает для большинства задач. 
; Также у нас должна быть очередь программных таймеров, размещенных в ОЗУ. На каждый таймер отводится три байта:
; 
; 	1 байт		2 байт		3 байт
; 	76543210	76543210	76543210
; 	nnnnnnnn	tttttttt	TTTTTTTT
; 
; где:
; 	nnnnnnnn	- Идентификатор Задачи	(где задача==0 означает "нет Таймера")
; 	tttttttt	— выдержка в миллисекундах (мл.байл) /little-endian/
; 	TTTTTTTT	— выдержка в миллисекундах (ст.байл)
; 
; Два байта позволяют организовать выдержку в 65,5 секунд.
; Один из свободных аппаратных таймеров программируем на то, чтобы он генерировал прерывание каждые 0.001с 
; По прерыванию аппаратного таймера - запускается обработчик RTOS_TIMER_SERVICE...




; Формат элемента пула Выжидателей (RTOS_WaitersPool):
; 
; 	1 байт		2 байт		3 байт
; 	76543210	76543210	76543210
; 	nnnnnnnn	aaaaaaaa	BpppAAAA
; 
; где:
; 	nnnnnnnn	- Идентификатор Задачи	(где задача==0, означает "нет Выжидателя")
; 	B		- Ожидаемое состояние бита, которое должено быть в тестируемой байтовой ячейке, для запуска Задачи на выполнение.
; 	ppp		- три бита кодируют номер позиции [0..7] тестируемого бита B в байтовой ячейке.
; 	AAAAaaaaaaaa	- 12-битный адрес [0x00..0x0FFF] тестируемой байтовой ячейки ОЗУ (регистра/порта/SRAM), даёт 4Kb диапазон адресации. Где "aaaaaaaa" - мл.байт, "AAAA" - ст.байт адреса.
; 
; Память вычитывается инструкцией "LD" (что даёт сквозную адресацию памяти).
; Итак, доступно к адресации 4Kb памяти (4096 байт): в т.ч. РОН, регистры ввода/вывода, SRAM.
; Из них, охватываемый диапазон SRAM = 0x1000 - SRAM_START. Что возможно будет меньше, чем вся доступная память SRAM_SIZE? 
; 	Этого вполне достаточно для подавляющего большинства используемых МК: младших моделей (с 2Kb и менее SRAM).
; 	Адресации не хватит только для самых мощных МК (с 4Кб и более SRAM), для которых уже не рассчитана сама ассемблерная RTOS - слишком много памяти, нужно программировать на Си...
; 	Например, для ATmega64 и ATmega128 - покрывается только 93% из  4Кб SRAM. (ещё можно как-то использовать, учитывая, что в конце памяти - только Стек, нет статических данных)
; 	          для ATmega640            - покрывается только 43% из  8Кб SRAM.
; 	          для ATmega1284           - покрывается только 23% из 16Кб SRAM.




; Формат элемента очереди Задач (RTOS_TaskQueue):
; 	Просто вектор из байтов, Номеров-индексов Задач.
; 	Пустой "хвост очереди" забивается нулями (кодом $00).




;=== END "RTOS-data.inc" ===================================================
; coded by (c) Celeron, 2014 @ http://we.easyelectronics.ru/my/Celeron/
