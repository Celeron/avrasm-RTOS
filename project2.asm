
	.NOLIST				; Disable listfile generation.
	;.include "tn10def.inc"		; Используем HAL Микроконтроллера "ATtiny10"
	.include "tn2313def.inc"	; Используем HAL Микроконтроллера "ATtiny2313"
	;.include "m8def.inc"		; Используем HAL Микроконтроллера "ATmega8"
	.include "macrobaselib.inc"	; Библиотека базовых Макроопределений.
	.include "macroapp.inc"		; Прикладные Макроопределения, используемые при реализации логики приложения.
	.include "RTOS_macro.inc"	; Макросы, реализующие прикладной интерфейс RTOS
	.LIST				; Reenable listfile generation.
	;.LISTMAC			; Turn macro expansion on?	(При отладке, отображать тела внедрённых Макросов в дизассемблированном коде - обычно, не следует включать, т.к. генерирует много мусора.)

	.include "data.inc"		; Данные программы:	(включаются после макроопределений!)
					;	Константы и псевдонимы Регистров; 
					;	Сегмент SRAM и Переменные; 
					;	Сегмент EEPROM.


;***************************************************************************
;*
;*  FLASH (сегмент кода)
;*
;***************************************************************************
			.CSEG

		.ORG	0x0000		; (RESET) 
		RJMP	RESET
		.include "ivectors.inc"	; Таблица векторов на обработчики прерываний


;***** BEGIN Interrupt handlers section ************************************


;---------------------------------------------------------------------------
;
; "Служба Таймеров Ядра RTOS" (Main Timer Service) 
; включена в обработчик прерывания от аппаратного Таймера/Счётчика.
;
; (Примечание: для перенастройки на использование другого Таймера или Режима - следует править код 
; Инициализации "RTOS_INIT" и Таблицу векторов прерываний "ivectors.inc".)
;
;---------------------------------------------------------------------------

RTOS_TIMER_HANDLER:
;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в прерывании аппаратного таймера, запускаться каждую 1мс!)
;===========================================================================
		RTOS_TIMER_SERVICE				; Служба таймеров RTOS 

	.ifdef	_RTOS_USE_TIMER0_OVERFLOW_
		PUSH	temp
	.ifndef	TCNT0L
		; В случае 8-разрядного Timer/Counter0
		OUTI	TCNT0,	256-Low(CTimerDivider)		; преИнициализировать начальное значение счётчика
	.else
		; В случае 16-разрядного Timer/Counter0
		; Note: To do a 16-bit write, the high byte must be written before the low byte. For a 16-bit read, the low byte must be read before the high byte.
		; 	It is important to notice that accessing 16-bit registers are atomic operations. Aware interrupts, use cli/sei!
		OUTI	TCNT0H,	High(65536-CTimerDivider)
		OUTI	TCNT0L,	Low (65536-CTimerDivider)	; преИнициализировать начальное значение счётчика
	.endif
		POP	temp
	.endif
;===========================================================================
		RETI					; выходим из прерывания



;---------------------------------------------------------------------------
;
; Прерывания обслуживающие USART: 
; Обработчик события "Приём байта осуществлён"
;
;---------------------------------------------------------------------------

Uart_RCV:
		PUSHF				; сохраняет часто используемые регистры: SREG и TEMP (TEMP1)
		PUSH 	ZL	
		PUSH 	ZH

		IN	temp1,UDR		; полученный байт - тут же отправляем обратно
		OUT	UDR,temp1		; (функционал "loopback")

		STS	Blink_ON,temp1
		PLAN_TASK	TS_LED_blink

		POP 	ZH
		POP 	ZL
		POPF
		RETI



;***** END Interrupt handlers section 


;***** ИНИЦИАЛИЗАЦИЯ *******************************************************
RESET:
		STACKINIT	; Инициализация стека
		RAMFLUSH	; Очистка памяти
		GPRFLUSH	; Очистка РОН


;***** BEGIN Internal Hardware Init ****************************************


; Инициализация USART:

		USART_INIT
;.equ	UDR=0	;debug stub (TODO: удалить потом)


; Инициализация Портов:

		SBI	LED_D,LED
		LED_OFF

		SBI	ENABLE_D,ENABLE
		ENABLE_OFF


;***** END Internal Hardware Init 


;***** BEGIN External Hardware Init ****************************************
;***** END External Hardware Init 


;***** BEGIN "Run once" section (запуск фоновых процессов) *****************


; Инициализация RTOS:

;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в коде инициализации микроконтроллера, запускаться единожды после "Reset"!)
;===========================================================================
		RTOS_INIT
;===========================================================================


; Инициализация и первичный запуск "Кооперативных Задач":

		; "Задача" все равно сформирована как "подпрограмма", так что как зайдет так и выйдет, а таймер запустится и дальше по цепи...
		; То есть Задачу можно стартануть и "как Подпрограмму", простым RCALL - тогда она выполнится мгновенно (что допустимо, здесь, для первого раза).
		; А можно запускать и "как Задачу" (через отдельные макросы PLAN_TASK_*) - выполнится в порядке общей очереди.
		RCALL		Task_TextTime	; Обрати внимание на то, что прямому RCALL мы указываем на метку, 
		PLAN_TASK	TS_Led_Blink	; а через API мы передаем идентификатор задачи.


;***** END "Run once" section 

;***** BEGIN "Main" section ************************************************

MAIN:

;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в секции "Main", крутиться постоянно!)
;===========================================================================
		SEI					; Разрешаем прерывания (сразу после каждой отработки прикладной Задачи, чтобы избежать ошибочного блокирования критических системных функций)	(Примечание: если вы всё же хотите в прикладных Задачах управлять прерываниями, что настоятельно не рекомендуется, то перенесите эту инструкцию SEI в "Run once" section...)
		WDR					; Reset Watch DOG (Если не "погладить" "собаку", то она устроит конец света в виде reset для процессора)
		RCALL 	RTOS_METHOD_ProcessTaskQueue	; Обработка системной очереди Задач
		RJMP 	MAIN				; Закругляем основной цикл микроядра RTOS
;===========================================================================


;***** END "Main" section 

;***** BEGIN Procedures section ********************************************

	; Внимание! В отличие от Макросов, Код процедур, всегда и полностью, 
	; включается в сегмент данных программы - занимает место! 
	; Поэтому, здесь должны быть включены только те процедуры, которые 
	; реально используются. (Остальные - следует /* закомментировать */.)

	;.include "genproclib.inc"	; Библиотека стандартных Подпрограмм.



;***** END Procedures section 

;***** BEGIN "RTOS Tasks" section ******************************************

	; "ЗАДАЧИ кооперативной RTOS" - это особые Подпрограммы: 
	;
	; 1) ОФОРМЛЕНИЕ
	;    Как и обычные процедуры - они имеют "метку входа" (адрес/имя), 
	;    а выход из них осуществляется только через RET (нельзя использовать RETI - это не обработчики прерываний!)
	;
	; 2) ПАРАМЕТРЫ
	;    Но "Задачи кооперативной RTOS" не могут иметь "регистровых параметров":
	;    Т.к. они запускаются опосредованно, через "Дисперчер Задач RTOS", в порядке очереди - то между запусками разных запланированных задач проходит неопределённое время, и происходит множество неконтролируемых операций с РОН. 
	;    Таким образом, Задачи должны управляться только данными в SRAM и в регистрах ввода/вывода!
	;    (Примечание: исключение могут составлять выделенные Задаче "регистровые переменные", но это редкость - см. обсуждаются в п.5.1)
	;
	; 3) ЗАПУСК
	;    "Задачи RTOS" никогда не запускаются непосредственно, через CALL <адрес>, как обычные подпрограммы!
	;    Все Задачи запускаются только опосредованно - через механизмы RTOS ("очередь задач" и "диспетчер задач").
	; 3.1) Задачи могут быть "запланированы к запуску" (по их порядковому номеру в индексной таблице "RTOS_TaskProcs"):
	;      либо "как можно скорее" (через PLAN_TASK),
	;      или "отложенный запуск, спустя заданное время, в мс" (через PLAN_TASK_TIMED, см. ниже п.7),
	;      или "при наступлении внешнего события, состояния аппаратного устройства, состояния флага в памяти" (через PLAN_TASK_WAITER, см. ниже п.8).
	;      В любом случае, передача управления между задачами никогда не происходит мгновенно - между ними происходит, как минимум один, проход цикла "Диспетчера задач"...
	; 3.2) Поэтому, все Задачи необходимо предварительно зарегистрировать в системе: 
	;      внести <адрес> в индексную таблицу "RTOS_TaskProcs", под определённым порядковым номером <индекс>;
	;      и для облегчения последующей идентификации, можно присвоить этот номер символической константе: .equ TS_TaskX = <индекс>.
	; 3.3) Исключение составляет: системная задача "холостой цикл" Task_Idle, под номером =0 в индексной таблице. 
	;      Никогда не планируйте/не добавляйте задачу Task_Idle в очередь на выполнение! (она сама, особым образом, обрабатывается RTOS: запускается при пустой "очереди задач")
	;
	; 4) ХОД ВЫПОЛНЕНИЯ
	;    Во время исполнения "кооперативной Задачи" управление не может быть насильно передано никакой другой "Задаче", ни службам RTOS! 
	;    (только аппаратные прерывания всё-ещё могут прервать эксклюзивный ход выполнения Задачи)
	; 4.1) Поэтому "кооперативная Задача", во время своего выполнения, может не опасаться за сохранность данных в РОН, SRAM, и регистрах ввода/вывода (состояниях аппаратной периферии, ПУ): 
	;      в этом наибольшая _выгода_ "кооперативной ОС", перед "вытесняющей ОС" - что каждой Задаче не надо отдельно заботиться/защищаться от всех других "конкурирующих процессов", код проще!
	;      (не требуется покрывать код критическими секциями, использовать мьютексы для разделения критических ресурсов, использовать прочие прелести "синхронизации межпроцессного взаимодействия")
	; 4.2) С другой стороны, во время исполнения Задачи, всё-ещё может произойти "запуск прерывания"! 
	;      Но код всех прерываний, безусловно, должен сберегать содержимое всех используемых РОН, через стек - они защищены.
	;      Однако, поскольку прерывание может влиять на содержимое иных разделяемых ресурсов (содержимое SRAM и состояния ПУ) - 
	;      при работе с критическими аппаратными ресурсами (например, при записи в EEPROM), в коде задач _допускается_ использовать CLI/SEI экранирование отдельных секций!
	; 4.3) Впрочем, Задачам недозволено запрещать прерывания надолго (дольше 1мс), чтобы не нарушать работу RTOS!
	;      Также, Задача не может запретить прерывания перманентно - как только завершится текущая Задача, то RTOS автоматически разрешит прерывания (SEI).
	;         (Например, невозможно реализовать функционал: Задача1 запретила прерывания, а запущенная следом Задача2 их вновь разрешила.
	;         Но это и бессмысленно: если запретить прерывания, то остановится "таймерная служба RTOS" - все "отложенные Задачи" будут заблокированы, не исполнятся никогда; и прерывания также никакие не возникнут - поэтому нет смысла так разбивать Задачу на подЗадачи...)
	;      Все "критические секции" необходимо отрабатывать в рамках одной Задачи! Вставляйте пустые циклы задержки, между CLI/SEI, если требуется ("тупить фиксированное число циклов" или "ожидать бит в системном регистре").
	;
	; 5) ОСОБЕННОСТИ ПРОГРАММИРОВАНИЯ
	;    У "кооперативных Задач", есть _важная привилегия_ , которой не обладают (асинхронно запускаемые) обработчики прерываний: 
	;    Задачи могут не защищать СОДЕРЖИМОЕ РЕГИСТРОВ (РОН) через стек, вообще, как будто задачи выполняются на процессоре эксклюзивно.
	;    (Повторюсь: не требуется сохранять в стек никакие используемые регистры перед исполнением кода Задачи, и затем восстанавливать после выполнения перед выходом!)
	;    Но при этом, всё пространство регистрового файла РОН следует рассматриваеть только как "временные переменные"!
	; 5.1) [Исключение 1:	при некоторых условиях, содержимое регистров сохраняется даже перманентно, между задачами]
	;      Замечу, при отключенной оптимизации RTOS_OPTIMIZE_FOR_SMALL_MEMORY, все системные методы RTOS сберегают содержимое используемых регистров через стек (за исключением ZH:ZL, в RTOS_METHOD_ProcessTaskQueue). 
	;      Хотя, это не всегда гарантирует сохранность данных в регистрах между Задачами - ведь содержимое регистров может быть переписано кем угодно, любой другой пользовательской Задачей, причём в произвольном порядке (Задачи запускаются/диспетчеризуются в произвольном порядке, срабатывают по таймерам или внешним событиям)...
	;      Поэтому, если вы не выделите некий регистр (под "регистровую переменную") некой Задаче эксклюзивно (т.е. чтобы никакая другая задача его не использовала), то даже при отключенной оптимизации RTOS_OPTIMIZE_FOR_SMALL_MEMORY - сохранность его содержимого не гарантируется.
	;      Ну или, заставить все Задачи сберегать используемые РОН в стеке - как в обработчиках прерываний... Но это гемор и расточительство памяти! (Нерациональный стиль программирования.)
	; 5.2) [Исключение 2:	обратная ситуация, когда некоторые регистры вообще нельзя использовать]
	;      [Это ещё требует уточнения, т.к. я не работал с "boot loader", и не представляю всех особенностей функционирования МК в этом режиме!]
	;      Ещё следует иметь в виду, что для некоторых продолжительных системных операций (например, при использовании функционала "boot loader"), выполняемых параллельно работе ядра ОС и прикладным Задачам, используются предопределённые регистры (R1:R0, RAMPX:X, RAMPY:Y, RAMPZ:Z, и др. temp1, temp2, looplo, loophi, spmcrval), и ещё требуется целая страница памяти в SRAM.
	;      Если таковые "системные операции" используются (см. инструкцию SPM), то в коде Задач: данные регистры использовать вообще нельзя или требуется их экранировать!
	;      Впрочем, функционал "boot loader" используется редко. Причём, когда отрабатывает "boot loader", то работу RTOS и всех прикладных Задач - следует остановить вовсе! И перевести микроконтроллер в _эксклюзивный_ сервисный режим... А когда "boot loader" отработает, то микроконтроллер (со всеми Задачами) будет принудительно перезапущен (RESET)...
	;      Таким образом, обычно, при написании кода Задач - на эти ситуации рассчитывать не следует - не актуально.
	;
	; 6) МЕТОДИКА ПРОЕКТИРОВАНИЯ
	;    Функционально, алгоритм решения сложной прикладной задачи разбивается на подзадачи - каждая из которых оформляется в код отдельной "кооперативной Задачи". 
	;    Таковые Задачи могут выполняется относительно других: последовательно, 
	;    или условно (отдельные ветки IF-THEN-ELSE можно оформить как отдельные Задачи, и запускать через PLAN_TASK), 
	;    или спустя определянную задержку времени (Задачи, планируемые через PLAN_TASK_TIMED),
	;    или спустя неопределённое ожидаение внешнего события или состояния аппаратного устройства: приход данных в порт, завершение операции с ADC или EEPROM, событие компаратора и т.п. (Задачи, планируемые через PLAN_TASK_WAITER)
	; 6.1) Код каждой Задачи должен быть атомарен. Каждая Задача при запуске: вычитывает, всё что нужно её алгоритму, из SRAM и регистров ввода/вывода; делает полезную работу; сохраняет результаты в SRAM; завершается (RET).
	; 6.2) Код каждой Задачи должен выполняться максимально быстро, как и обработчики прерывания. Никогда не используйте "тупые задержки" в коде! Вместо этого, разделите Задачу на две подЗадачи: в первой части, сохраните в SRAM все промежуточные данные нужные алгоритму второй части, и запланируйте запуск второй подзадачи (через PLAN_TASK_TIMED)...
	; 6.3) Разумеется, для решения каждой отдельной прикладной задачи - потребуется определить целую серию подпрограмм "кооперативных Задач". Чтобы упорядочить этот колхоз - рекомендуется использовать разные трюки: 
	;      Имена давать Задачам, сформированные особым образом, префиксно: TS_TaskX_Begin, TS_TaskX_Check, TS_Task_Finish... 
	;      Перечислять Задачи в индексной таблице "RTOS_TaskProcs" последовательно, группами... 
	;      Давать описания коду и разделять его по секциям... и т.п.
	;
	; 7) Порядок установки Таймеров:
	; TODO: описать...
	;
	; 8) Порядок установки Выжидающих:
	; TODO: описать...



;---------------------------------------------------------------------------
;Tasks
;---------------------------------------------------------------------------

; Системная задача "холостой цикл" (запускается при пустом конвеере)
; (важно: название не менять, задачу не убирать - используется системой RTOS)
Task_Idle:
		; Примечание: в Задачу "Idle" можно сунуть что нибудь простое, быстрое и некритичное.
		; Хотя я обычно оставляю её пустой.
		NOP	
		RET

;-----------------------------------------------------------------------------
Task_Send:
		LDS	temp1,UART_CNT
		LDI	ZL, Low(Message*2)
		LDI	ZH, High(Message*2)

		ADD	ZL,temp1
		CLR	temp2
		ADC	ZH,temp2

		INC	temp1
		STS	UART_CNT,temp1

		LPM	temp1,Z
			
		CPI	temp1,0
		BREQ	Final
			
		OUT	UDR,temp1

		SetTimerTask TS_Send,50

		ret
Final:
		CLR	temp1
		STS	UART_CNT,temp1
		RET


Message:	.db	"Fucking world!  ",0


;-----------------------------------------------------------------------------
Task_LedBlink:
		LDS	temp1,Blink_ON
		CPI	temp1,0
		BREQ	Dark

		SetTimerTask	TS_Led_blink,200

		SBIC	LED_N,LED
		RJMP	Dark
Light:
		LED_ON
		RET
Dark:
		LED_OFF
		RET


;-----------------------------------------------------------------------------
Task_TextTime:
		SetTimerTask 	TS_TextTime,5000
		ENABLE_ON
		SetTimerTask 	TS_Send,500
		RET


;-----------------------------------------------------------------------------
Task4:		RET
;-----------------------------------------------------------------------------
Task5:		RET
;-----------------------------------------------------------------------------
Task6:		RET
;-----------------------------------------------------------------------------
Task7:		RET
;-----------------------------------------------------------------------------
Task8:		RET
;-----------------------------------------------------------------------------
Task9:		RET
;-----------------------------------------------------------------------------



;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в сегменте кода!)
;===========================================================================
	.include "RTOS_kernel.inc"	; Подключаем ядро ОС
;===========================================================================

; Таблица "индексных переходов" на реальные адреса Задач.
; Правила:
; 	Имейте в виду, что в эту таблицу должны быть добавлены все Подпрограммы, которые вы хотите вызывать как "Задачи RTOS".
; 	Порядок следования элементов не важен, но вы должны обязательно запомнить порядковый номер Задачи (индекс элемента в массиве) - по этому номеру вы потом будете планировать/вызывать эту Задачу к выполнению (с помощью макросов PLAN_TASK_*).
; 	Для снижения путаницы и повышения удобства программирования, рекомендуется определить также символьные псевдонимы каждому номеру-индексу, для каждой Задачи (см. определения расположенные в файле <macroapp.inc>).
; Полезный Приём:
; 	Т.к. элементы пула Таймеров и Выжидающих идентифицируются по УНИКАЛЬНОМУ номеру-индексу Задачи, то в пулах одновременно может присутствовать только ПО ОДНОМУ экземпляру каждой Задачи!
; 	А если нужно две одинаковые Задачи запланировать, по таймеру, в разное время? Так никто не запрещает повторно зарегистрировать эту Подпрограмму в таблицу переходов, на новый идентификатор - и будет тебе профит...
; Ограничения: 
; 	максимально возможное количество зарегистрированных в системе задач = 256шт.
; 	получаемые индексы задач = [0..255],
; 	включая одну обязательную системную задачу Task_Idle, под номером ==0

RTOS_TaskProcs:
	 	.dw	Task_Idle	; [  0]	системная задача "холостой цикл"  (важно: должна быть расположена по индексу=0 - используется системой RTOS)
		.dw	Task_Send	; [  1]
		.dw	Task_LedBlink	; [  2]
		.dw	Task_TextTime	; [  3]
		.dw	Task4		; [  4]
		.dw	Task5		; [  5]
		.dw	Task6		; [  6]
		.dw	Task7		; [  7]
		.dw	Task8		; [  8]
		.dw	Task9		; [  9]
		;...
		;.dw	Task255		; [255] последняя задача, зарегистрированная в системе



;***** END "RTOS Tasks" section
; coded by (c) DI HALT, 2008 @ http://easyelectronics.ru/
; coded by (c) Celeron, 2014 @ http://we.easyelectronics.ru/my/Celeron/
