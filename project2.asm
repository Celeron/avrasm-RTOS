
	.NOLIST				; Disable listfile generation.
	;.include "tn10def.inc"		; Используем HAL Микроконтроллера "ATtiny10"
	;.include "tn13Adef.inc" 	; Используем HAL Микроконтроллера "ATtiny13A"
	.include "tn2313def.inc"	; Используем HAL Микроконтроллера "ATtiny2313"
	;.include "m8def.inc"		; Используем HAL Микроконтроллера "ATmega8"
	;.include "m16def.inc"		; Используем HAL Микроконтроллера "ATmega16"
	;.include "m2560def.inc" 	; Используем HAL Микроконтроллера "ATmega2560"
	.include "macrobaselib.inc"	; Библиотека базовых Макроопределений.
	.include "macroapp.inc"		; Прикладные Макроопределения, используемые при реализации логики приложения.
	.include "RTOS_macro.inc"	; Макросы, реализующие прикладной интерфейс RTOS
	.LIST				; Reenable listfile generation.
	;.LISTMAC			; Turn macro expansion on?	(При отладке, отображать тела внедрённых Макросов в дизассемблированном коде - обычно, не следует включать, т.к. генерирует много мусора.)

	.include "data.inc"		; Данные программы:	(включаются обязательно после макроопределений!)
					;	Константы и псевдонимы Регистров; 
					;	Сегмент SRAM и Переменные; 
					;	Сегмент EEPROM.


;***************************************************************************
;*
;*  FLASH (сегмент кода)
;*
;***************************************************************************
			.CSEG

		.ORG	0x0000		; (RESET) 
		RJMP	RESET
		;.include "ivectors_tiny10.inc"		; Таблица векторов на обработчики прерываний для "ATtiny10"
		;.include "ivectors_tiny13.inc"		; Таблица векторов на обработчики прерываний для "ATtiny13(A)"
		.include "ivectors_tiny2313.inc"	; Таблица векторов на обработчики прерываний для "ATtiny2313"
		;.include "ivectors_mega8.inc"		; Таблица векторов на обработчики прерываний для "ATmega8"
		;.include "ivectors_mega16.inc"		; Таблица векторов на обработчики прерываний для "ATmega16"
		;.include "ivectors_mega2560.inc"	; Таблица векторов на обработчики прерываний для "ATmega2560"


;***** BEGIN Interrupt handlers section ************************************


;---------------------------------------------------------------------------
;
; "Служба Таймеров Ядра RTOS" (Main Timer Service) 
; включена в обработчик прерывания от аппаратного Таймера/Счётчика.
;
; (Примечание: для перенастройки на использование другого Таймера или Режима - следует править код 
; Инициализации "RTOS_INIT" и Таблицу векторов прерываний "ivectors.inc".)
;
;---------------------------------------------------------------------------

RTOS_TIMER_HANDLER:
;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в прерывании аппаратного таймера, запускаться каждую 1мс!)
;===========================================================================
	.if defined(RTOS_FEATURE_PLANTASK) && (defined(RTOS_FEATURE_PLANTIMER) || defined(RTOS_FEATURE_PLANWAITER))	; (служба таймеров используется только в этих режимах)
		RTOS_TIMER_SERVICE				; Служба таймеров RTOS 
	.endif

	.ifdef	RTOS_USE_TIMER0_OVERFLOW
		PUSH	temp
	.ifndef	TCNT0L
		; В случае 8-разрядного Timer/Counter0
		OUTI	TCNT0,	256-Low(CTimerDivider)		; преИнициализировать начальное значение счётчика
	.else
		; В случае 16-разрядного Timer/Counter0
		; Note: To do a 16-bit write, the high byte must be written before the low byte. For a 16-bit read, the low byte must be read before the high byte.
		; 	It is important to notice that accessing 16-bit registers are atomic operations. Aware interrupts, use cli/sei!
		OUTI	TCNT0H,	High(65536-CTimerDivider)
		OUTI	TCNT0L,	Low (65536-CTimerDivider)	; преИнициализировать начальное значение счётчика
	.endif
		POP	temp
	.endif
;===========================================================================
		RETI					; выходим из прерывания



;***** END Interrupt handlers section 


;***** ИНИЦИАЛИЗАЦИЯ *******************************************************
RESET:
		STACKINIT	; Инициализация стека
		RAMFLUSH	; Очистка памяти
		GPRFLUSH	; Очистка РОН


;***** BEGIN Internal Hardware Init ****************************************


; Инициализация USART:

;		USART_INIT


; Инициализация Портов:

;		...


;***** END Internal Hardware Init 


;***** BEGIN External Hardware Init ****************************************
;***** END External Hardware Init 


;***** BEGIN "Run once" section (запуск фоновых процессов) *****************


; Инициализация RTOS:

;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в коде инициализации микроконтроллера, запускаться единожды после "Reset"!)
;===========================================================================
		RTOS_INIT
;===========================================================================


; Инициализация и первичный запуск "Кооперативных Задач":

		; "Задача" все равно сформирована как "подпрограмма", так что как зайдет так и выйдет, а "шарманка" автомата запустится, и дальше будет исполняться по цепи...
		; То есть Задачу можно стартануть и "как Подпрограмму", простым RCALL - тогда она выполнится мгновенно (что допустимо, здесь, для первого раза).
		; А можно запускать и "как Задачу" (через специальный макрос PLAN_TASK) - выполнится в порядке общей очереди.
;		RCALL		Task1		; Обрати внимание на то, что прямому RCALL мы указываем на метку, 
;		PLAN_TASK	TS_Task1	; а через API мы передаем идентификатор задачи.


;***** END "Run once" section 

;***** BEGIN "Main" section ************************************************

MAIN:

;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в секции "Main", крутиться постоянно!)
;===========================================================================
		SEI					; Разрешаем прерывания (сразу после каждой отработки прикладной Задачи, чтобы избежать ошибочного блокирования критических системных функций)	(Примечание: если вы всё же хотите в прикладных Задачах управлять прерываниями, что настоятельно не рекомендуется, то перенесите эту инструкцию SEI в "Run once" section...)
		WDR					; Reset Watch DOG (Если не "погладить" "собаку", то она устроит конец света в виде reset для процессора)
	.if defined(RTOS_FEATURE_PLANTASK) && (defined(RTOS_FEATURE_PLANTIMER) || defined(RTOS_FEATURE_PLANWAITER))	; (служба таймеров используется только в этих режимах)
		RJMP	RTOS_METHOD_TimerService	; Служба таймеров RTOS 
		RTOS_METHOD_TimerService_ExitPoint:
	.endif
	.if defined(RTOS_FEATURE_PLANTASK)
		RCALL 	RTOS_METHOD_ProcessTaskQueue	; Обработка системной очереди Задач
	.endif
		RJMP 	MAIN				; Закругляем основной цикл микроядра RTOS
;===========================================================================


;***** END "Main" section 

;***** BEGIN Procedures section ********************************************

	; Внимание! В отличие от Макросов, Код процедур, всегда и полностью, 
	; включается в сегмент данных программы - занимает место! 
	; Поэтому, здесь должны быть включены только те процедуры, которые 
	; реально используются. (Остальные - следует /* закомментировать */.)

	;.include "genproclib.inc"	; Библиотека стандартных Подпрограмм.



;***** END Procedures section 

;***** BEGIN "RTOS Tasks" section ******************************************

	; "ЗАДАЧИ кооперативной RTOS" - это особые Подпрограммы: 
	;
	; 1) ОФОРМЛЕНИЕ
	;    Как и обычные процедуры - они имеют "метку входа" (адрес/имя), 
	;    а выход из них осуществляется только через RET (нельзя использовать RETI - это не обработчики прерываний!)
	;
	; 2) ПАРАМЕТРЫ
	;    Но "Задачи кооперативной RTOS" не могут иметь "регистровых параметров":
	;    Т.к. они запускаются опосредованно, через "Диспетчер Задач RTOS", в порядке очереди - то между запусками разных запланированных задач проходит неопределённое время, и происходит множество неконтролируемых операций с РОН. 
	;    Таким образом, Задачи должны управляться только данными в SRAM и в регистрах ввода/вывода!
	;    (Примечание: исключение могут составлять выделенные Задаче "регистровые переменные", но это редкость - см. обсуждаются в п.5.1)
	;
	; 3) ЗАПУСК
	;    "Задачи RTOS" никогда не запускаются непосредственно, через CALL <адрес>, как обычные подпрограммы!
	;    Все Задачи запускаются только опосредованно - через механизмы RTOS ("очередь задач" и "диспетчер задач").
	; 3.1) Задачи могут быть "запланированы к запуску" (по их порядковому номеру в индексной таблице "RTOS_TaskProcs"):
	;      либо "как можно скорее" (через PLAN_TASK),
	;      или "отложенный запуск, спустя заданное время, в мс" (через PLAN_TIMER, см. ниже п.7),
	;      или "при наступлении внешнего события, состояния аппаратного устройства, состояния флага в памяти" (через PLAN_WAITER, см. ниже п.8).
	;      В любом случае, передача управления между задачами никогда не происходит мгновенно - между ними происходит, как минимум один, проход цикла "Диспетчера задач"...
	; 3.2) Поэтому, все Задачи необходимо предварительно зарегистрировать в системе: 
	;      внести <адрес> в индексную таблицу "RTOS_TaskProcs", под определённым порядковым номером <индекс>;
	;      и для облегчения последующей идентификации, можно присвоить этот номер символической константе: .equ TS_TaskX = <индекс>.
	; 3.3) Исключение составляет: системная задача "холостой цикл" Task_Idle, под номером =0 в индексной таблице. 
	;      Никогда не планируйте/не добавляйте задачу Task_Idle в очередь на выполнение! (она сама, особым образом, обрабатывается RTOS: запускается при пустой "очереди задач")
	;
	; 4) ХОД ВЫПОЛНЕНИЯ
	;    Во время исполнения "кооперативной Задачи" управление не может быть насильно передано никакой другой "Задаче", ни службам RTOS! 
	;    (только аппаратные прерывания всё-ещё могут прервать эксклюзивный ход выполнения Задачи)
	; 4.1) Поэтому "кооперативная Задача", во время своего выполнения, может не опасаться за сохранность данных в РОН, SRAM, и регистрах ввода/вывода (состояниях аппаратной периферии, ПУ): 
	;      в этом наибольшая _выгода_ "кооперативной ОС", перед "вытесняющей ОС" - что каждой Задаче не надо отдельно заботиться/защищаться от всех других "конкурирующих процессов", код проще!
	;      (не требуется покрывать код критическими секциями, использовать мьютексы для разделения критических ресурсов, использовать прочие прелести "синхронизации межпроцессного взаимодействия")
	; 4.2) С другой стороны, во время исполнения Задачи, всё-ещё может произойти "запуск прерывания"! 
	;      Но код всех прерываний, безусловно, должен сберегать содержимое всех используемых РОН, через стек - они защищены.
	;      Однако, поскольку прерывание может влиять на содержимое иных разделяемых ресурсов (содержимое SRAM и состояния ПУ) - 
	;      при работе с критическими аппаратными ресурсами (например, при записи в EEPROM), в коде задач _допускается_ использовать CLI/SEI экранирование отдельных секций!
	; 4.3) Впрочем, Задачам недозволенно запрещать прерывания надолго (дольше 1мс), чтобы не нарушать работу RTOS!
	;      Также, Задача не может запретить прерывания перманентно - как только завершится текущая Задача, то RTOS автоматически разрешит прерывания (SEI).
	;         (Например, невозможно реализовать функционал: Задача1 запретила прерывания, а запущенная следом Задача2 их вновь разрешила.
	;         Но это и бессмысленно: если запретить прерывания, то остановится "таймерная служба RTOS" - все "отложенные Задачи" будут заблокированы, не исполнятся никогда; и прерывания также никакие не возникнут - поэтому нет смысла так разбивать Задачу на подЗадачи...)
	;      Все "критические секции" необходимо отрабатывать в рамках одной Задачи! Вставляйте пустые циклы задержки, между CLI/SEI, если требуется ("тупить фиксированное число циклов" или "ожидать бит в системном регистре").
	;
	; 5) ОСОБЕННОСТИ ПРОГРАММИРОВАНИЯ
	;    У "кооперативных Задач", есть _важная привилегия_ , которой не обладают (асинхронно запускаемые) обработчики прерываний: 
	;    Задачи могут не защищать СОДЕРЖИМОЕ РЕГИСТРОВ (РОН) через стек, вообще, как будто задачи выполняются на процессоре эксклюзивно.
	;    (Повторюсь: не требуется сохранять в стек никакие используемые регистры перед исполнением кода Задачи, и затем восстанавливать после выполнения перед выходом!)
	;    Но при этом, всё пространство регистрового файла РОН следует рассматривать только как "временные переменные"!
	; 5.1) [Исключение 1:	при некоторых условиях, содержимое регистров сохраняется даже перманентно, между задачами]
	;      Замечу, при отключенной оптимизации RTOS_OPTIMIZE_FOR_SMALL_MEMORY, все системные методы RTOS сберегают содержимое используемых регистров через стек (за исключением ZH:ZL, в RTOS_METHOD_ProcessTaskQueue). 
	;      Хотя, это не всегда гарантирует сохранность данных в регистрах между Задачами - ведь содержимое регистров может быть переписано кем угодно, любой другой пользовательской Задачей, причём в произвольном порядке (Задачи запускаются/диспетчеризуются в произвольном порядке, срабатывают по таймерам или внешним событиям)...
	;      Поэтому, если вы не выделите некий регистр (под "регистровую переменную") некой Задаче эксклюзивно (т.е. чтобы никакая другая задача его не использовала), то даже при отключенной оптимизации RTOS_OPTIMIZE_FOR_SMALL_MEMORY - сохранность его содержимого не гарантируется.
	;      Ну или, заставить все Задачи сберегать используемые РОН в стеке - как в обработчиках прерываний... Но это гемор и расточительство памяти! (Нерациональный стиль программирования.)
	; 5.2) [Исключение 2:	обратная ситуация, когда некоторые регистры вообще нельзя использовать]
	;      [Это ещё требует уточнения, т.к. я не работал с "boot loader", и не представляю всех особенностей функционирования МК в этом режиме!]
	;      Ещё следует иметь в виду, что для некоторых продолжительных системных операций (например, при использовании функционала "boot loader"), выполняемых параллельно работе ядра ОС и прикладным Задачам, используются предопределённые регистры (R1:R0, RAMPX:X, RAMPY:Y, RAMPZ:Z, и др. temp1, temp2, looplo, loophi, spmcrval), и ещё требуется целая страница памяти в SRAM.
	;      Если таковые "системные операции" используются (см. инструкцию SPM), то в коде Задач: данные регистры использовать вообще нельзя или требуется их экранировать!
	;      Впрочем, функционал "boot loader" используется редко. Причём, когда отрабатывает "boot loader", то работу RTOS и всех прикладных Задач - следует остановить вовсе! И перевести микроконтроллер в _эксклюзивный_ сервисный режим... А когда "boot loader" отработает, то микроконтроллер (со всеми Задачами) будет принудительно перезапущен (RESET)...
	;      Таким образом, обычно, при написании кода Задач - на эти ситуации рассчитывать не следует - не актуально.
	;
	; 6) МЕТОДИКА ПРОЕКТИРОВАНИЯ
	;    Функционально, алгоритм решения сложной прикладной задачи разбивается на подзадачи - каждая из которых оформляется в код отдельной "кооперативной Задачи". 
	;    Таковые Задачи могут выполняется относительно других: последовательно, 
	;    или условно (отдельные ветки IF-THEN-ELSE можно оформить как отдельные Задачи, и запускать через PLAN_TASK), 
	;    или спустя определённую задержку времени (Задачи, планируемые через PLAN_TIMER),
	;    или спустя неопределённое ожидание внешнего события или состояния аппаратного устройства: приход данных в порт, завершение операции с ADC или EEPROM, событие компаратора и т.п. (Задачи, планируемые через PLAN_WAITER)
	; 6.1) Код каждой Задачи должен быть атомарен. Каждая Задача при запуске: вычитывает, всё что нужно её алгоритму, из SRAM и регистров ввода/вывода; делает полезную работу; сохраняет результаты в SRAM; завершается (RET).
	; 6.2) Код каждой Задачи должен выполняться максимально быстро, как и обработчики прерывания. Никогда не используйте "тупые задержки" в коде! Вместо этого, разделите Задачу на две подЗадачи: в первой части, сохраните в SRAM все промежуточные данные нужные алгоритму второй части, и запланируйте запуск второй подзадачи (через PLAN_TIMER)...
	; 6.3) Разумеется, для решения каждой отдельной прикладной задачи - потребуется определить целую серию подпрограмм "кооперативных Задач". Чтобы упорядочить этот колхоз - рекомендуется использовать разные трюки: 
	;      Имена давать Задачам, сформированные особым образом, префиксно: TS_TaskX_Begin, TS_TaskX_Check, TS_Task_Finish... 
	;      Перечислять Задачи в индексной таблице "RTOS_TaskProcs" последовательно, группами... 
	;      Давать описания коду и разделять его по секциям... и т.п.
	;
	;
	; 7) Порядок установки Таймера:
	; 	1. Добавить новый Таймер, вызвав API-метод:  PLAN_TIMER tasknumber,delay
	; 	   - Если в пуле уже существует Таймер для задачи <tasknumber>, то его текущий "счётчик времени" будет переписан на значение <delay>.	/Прикол с апдейтом таймера кажется лишним, но реально часто пригождается. Например, когда по условию надо отложить событие. Берешь и перезаписываешь таймер, подобно программному watchdog./
	; 	   - Иначе, при наличии в пуле свободного места, регистрируется новый Таймер: для запуска задачи <tasknumber>, через время <delay> = [0..65535] ms.
	; 	2. При необходимости перепланировать таймер на другое время, до того как он сработал - вновь вызвать API-метод:  PLAN_TIMER tasknumber,delay
	; 	3. Перепланировывать таймер можно неограниченное количество раз, лишь бы - делать это до того, как он сработает...]
	; 	4. При необходимости же вовсе отменить запланированный запуск задачи - удалить таймер, вызвав API-метод:  REMOVE_TIMER tasknumber
	; 	5. Каждую ~1ms реального времени, по прерыванию, запускается "Служба таймеров RTOS", которая:
	; 	   - Декрементирует счётчики, всем активным Таймерам в пуле, на (-1)...
	; 	   - Если, при этом, значение счётчика достигает =0 ?
	; 		- то связанная Задача <tasknumber> добавляется в очередь RTOS_TaskQueue, на выполнение;
	; 		- а сам сработавший Таймер, при этом, деактивируется/самоудаляется, освобождая Элемент пула...
	; 	6. Задача, посланная в "системную очередь" RTOS_TaskQueue, будет выполнена в порядке общей очереди...
	;    Побочные эффекты: 
	; 	API-методы PLAN_TIMER/REMOVE_TIMER, при исполнении, портят содержимое в некоторых регистрах: в зависимости от режима RTOS_OPTIMIZE_FOR_SMALL_MEMORY, либо только "параметровые регистры", либо также и "временные регистры" (см. комментарии в секции "Subroutine Register Variables", соответствующего системного метода).
	; 	Для управления Таймерами предлагаются также API-методы: SAFE_PLAN_TIMER/SAFE_REMOVE_TIMER, которые гарантированно не портят вообще никаких регистров, но они доступны только в режиме выключенной оптимизации RTOS_OPTIMIZE_FOR_SMALL_MEMORY (при этом, используется Стек - нужна дополнительная оперативная память).
	; 
	; 
	; 8) Порядок установки Выжидателя:
	; 	1. Добавить новый Выжидатель, вызвав API-метод:  PLAN_WAITER tasknumber,address,bit,state
	; 	   - Если в пуле уже существует Выжидатель для задачи <tasknumber>, то его текущие "условия запуска" будет переписаны на значения <address,bit,state>.
	; 	   - Иначе, при наличии в пуле свободного места, регистрируется новый Выжидатель: для запуска задачи <tasknumber>, при наступлении "заданных условий" (значения бита в памяти), которое может произойти через любое неопределённое время (проверка состояния бита осуществляется периодически, каждые 1ms).
	; 	2. При необходимости перепланировать выжидатель, на новые условия, до того как он сработал - вновь вызвать API-метод:  PLAN_WAITER tasknumber,address,bit,state
	; 	3. Перепланировывать выжидатель можно неограниченное количество раз, лишь бы - делать это до того, как он сработает...]
	; 	4. При необходимости же вовсе отменить запланированный запуск задачи - удалить выжидатель, вызвав API-метод:  REMOVE_WAITER tasknumber
	; 	5. Каждую ~1ms реального времени, по прерыванию, запускается "Служба таймеров RTOS", которая:
	; 	   - Проходясь по всем активным Выжидателям в пуле, вычитывает байт из памяти по адресу <address>, и проверяет в нём значение бита номер <bit>...
	; 	   - Если значение бита = <state> ?
	; 		- то связанная Задача <tasknumber> добавляется в очередь RTOS_TaskQueue, на выполнение;
	; 		- а сам сработавший Выжидатель, при этом, деактивируется/самоудаляется, освобождая Элемент пула...
	; 	6. Задача, посланная в "системную очередь" RTOS_TaskQueue, будет выполнена в порядке общей очереди...
	;    Побочные эффекты: 
	; 	API-методы PLAN_WAITER/REMOVE_WAITER, при исполнении, портят содержимое в некоторых регистрах: в зависимости от режима RTOS_OPTIMIZE_FOR_SMALL_MEMORY, либо только "параметровые регистры", либо также и "временные регистры" (см. комментарии в секции "Subroutine Register Variables", соответствующего системного метода).
	; 	Для управления Выжидателями предлагаются также API-методы: SAFE_PLAN_WAITER/SAFE_REMOVE_WAITER, которые гарантированно не портят вообще никаких регистров, но они доступны только в режиме выключенной оптимизации RTOS_OPTIMIZE_FOR_SMALL_MEMORY (при этом, используется Стек - нужна дополнительная оперативная память).



;---------------------------------------------------------------------------
;Tasks
;---------------------------------------------------------------------------

; Системная задача "холостой цикл" (запускается при пустом конвейере)
; (важно: название не менять, задачу не убирать - используется системой RTOS)
Task_Idle:
		; Примечание: в Задачу "Idle" можно сунуть что нибудь простое, быстрое и некритичное.
		; Хотя я обычно оставляю её пустой.
		NOP	
		RET

;-----------------------------------------------------------------------------
Task1:		RET
;-----------------------------------------------------------------------------
Task2:		RET
;-----------------------------------------------------------------------------
Task3:		RET
;-----------------------------------------------------------------------------
Task4:		RET
;-----------------------------------------------------------------------------
Task5:		RET
;-----------------------------------------------------------------------------
Task6:		RET
;-----------------------------------------------------------------------------
Task7:		RET
;-----------------------------------------------------------------------------
Task8:		RET
;-----------------------------------------------------------------------------
Task9:		RET
;-----------------------------------------------------------------------------



;===========================================================================
; RTOS Here	(Внимание: этот блок должен располагаться в сегменте кода!)
;===========================================================================
	.include "RTOS_kernel.inc"	; Подключаем ядро ОС
;===========================================================================

; Таблица "индексных переходов" на реальные адреса Задач.
; Правила:
; 	Имейте в виду, что в эту таблицу должны быть добавлены все Подпрограммы, которые вы хотите вызывать как "Задачи RTOS".
; 	Порядок следования элементов не важен, но вы должны обязательно запомнить порядковый номер Задачи (индекс элемента в массиве) - по этому номеру вы потом будете планировать/вызывать эту Задачу к выполнению (с помощью макросов PLAN_TASK_*).
; 	Для снижения путаницы и повышения удобства программирования, рекомендуется определить также символьные псевдонимы каждому номеру-индексу, для каждой Задачи (см. определения расположенные в файле <macroapp.inc>).
; Полезный Приём:
; 	Т.к. элементы пула Таймеров и Выжидателей идентифицируются по УНИКАЛЬНОМУ "номеру-индексу Задачи", то в пулах одновременно может присутствовать только ПО ОДНОМУ экземпляру каждой Задачи!
; 	А если нужно две одинаковые Задачи запланировать, по таймеру, в разное время? Так никто не запрещает зарегистрировать эту Подпрограмму повторно, в таблицу переходов, на новый идентификатор - и будет тебе профит...
; Ограничения: 
; 	максимально возможное количество зарегистрированных в системе задач = 256шт.
; 	получаемые индексы задач = [0..255],
; 	включая одну обязательную системную задачу Task_Idle, под номером ==0

RTOS_TaskProcs:
	 	.dw	Task_Idle	; [  0]	системная задача "холостой цикл"  (важно: должна быть расположена по индексу=0 - используется системой RTOS)
		.dw	Task1		; [  1]
		.dw	Task2		; [  2]
		.dw	Task3		; [  3]
		.dw	Task4		; [  4]
		.dw	Task5		; [  5]
		.dw	Task6		; [  6]
		.dw	Task7		; [  7]
		.dw	Task8		; [  8]
		.dw	Task9		; [  9]
		;...
		;.dw	Task255		; [255] последняя возможная задача, зарегистрированная в системе



;***** END "RTOS Tasks" section
; coded by (c) DI HALT, 2008 @ http://easyelectronics.ru/
; coded by (c) Celeron, 2014 @ http://we.easyelectronics.ru/my/Celeron/
